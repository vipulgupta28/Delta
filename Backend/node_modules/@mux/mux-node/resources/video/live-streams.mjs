// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
import { APIResource } from "../../resource.mjs";
import { isRequestOptions } from "../../core.mjs";
import { BasePage } from "../../pagination.mjs";
export class LiveStreams extends APIResource {
    /**
     * Creates a new live stream. Once created, an encoder can connect to Mux via the
     * specified stream key and begin streaming to an audience.
     *
     * @example
     * ```ts
     * const liveStream = await client.video.liveStreams.create({
     *   new_asset_settings: { playback_policies: ['public'] },
     *   playback_policies: ['public'],
     * });
     * ```
     */
    create(body, options) {
        return this._client.post('/video/v1/live-streams', {
            body,
            defaultBaseURL: 'https://api.mux.com',
            ...options,
        })._thenUnwrap((obj) => obj.data);
    }
    /**
     * Retrieves the details of a live stream that has previously been created. Supply
     * the unique live stream ID that was returned from your previous request, and Mux
     * will return the corresponding live stream information. The same information is
     * returned when creating a live stream.
     *
     * @example
     * ```ts
     * const liveStream = await client.video.liveStreams.retrieve(
     *   'LIVE_STREAM_ID',
     * );
     * ```
     */
    retrieve(liveStreamId, options) {
        return this._client.get(`/video/v1/live-streams/${liveStreamId}`, {
            defaultBaseURL: 'https://api.mux.com',
            ...options,
        })._thenUnwrap((obj) => obj.data);
    }
    /**
     * Updates the parameters of a previously-created live stream. This currently
     * supports a subset of variables. Supply the live stream ID and the updated
     * parameters and Mux will return the corresponding live stream information. The
     * information returned will be the same after update as for subsequent get live
     * stream requests.
     *
     * @example
     * ```ts
     * const liveStream = await client.video.liveStreams.update(
     *   'LIVE_STREAM_ID',
     *   {
     *     latency_mode: 'standard',
     *     max_continuous_duration: 1200,
     *     reconnect_window: 30,
     *   },
     * );
     * ```
     */
    update(liveStreamId, body, options) {
        return this._client.patch(`/video/v1/live-streams/${liveStreamId}`, {
            body,
            defaultBaseURL: 'https://api.mux.com',
            ...options,
        })._thenUnwrap((obj) => obj.data);
    }
    list(query = {}, options) {
        if (isRequestOptions(query)) {
            return this.list({}, query);
        }
        return this._client.getAPIList('/video/v1/live-streams', LiveStreamsBasePage, {
            query,
            defaultBaseURL: 'https://api.mux.com',
            ...options,
        });
    }
    /**
     * Deletes a live stream from the current environment. If the live stream is
     * currently active and being streamed to, ingest will be terminated and the
     * encoder will be disconnected.
     *
     * @example
     * ```ts
     * await client.video.liveStreams.delete('LIVE_STREAM_ID');
     * ```
     */
    delete(liveStreamId, options) {
        return this._client.delete(`/video/v1/live-streams/${liveStreamId}`, {
            defaultBaseURL: 'https://api.mux.com',
            ...options,
            headers: { Accept: '*/*', ...options?.headers },
        });
    }
    /**
     * (Optional) End the live stream recording immediately instead of waiting for the
     * reconnect_window. `EXT-X-ENDLIST` tag is added to the HLS manifest which
     * notifies the player that this live stream is over.
     *
     * Mux does not close the encoder connection immediately. Encoders are often
     * configured to re-establish connections immediately which would result in a new
     * recorded asset. For this reason, Mux waits for 60s before closing the connection
     * with the encoder. This 60s timeframe is meant to give encoder operators a chance
     * to disconnect from their end.
     *
     * @example
     * ```ts
     * await client.video.liveStreams.complete('LIVE_STREAM_ID');
     * ```
     */
    complete(liveStreamId, options) {
        return this._client.put(`/video/v1/live-streams/${liveStreamId}/complete`, {
            defaultBaseURL: 'https://api.mux.com',
            ...options,
            headers: { Accept: '*/*', ...options?.headers },
        });
    }
    /**
     * Create a new playback ID for this live stream, through which a viewer can watch
     * the streamed content of the live stream.
     *
     * @example
     * ```ts
     * const playbackId =
     *   await client.video.liveStreams.createPlaybackId(
     *     'LIVE_STREAM_ID',
     *     { policy: 'signed' },
     *   );
     * ```
     */
    createPlaybackId(liveStreamId, body, options) {
        return this._client.post(`/video/v1/live-streams/${liveStreamId}/playback-ids`, {
            body,
            defaultBaseURL: 'https://api.mux.com',
            ...options,
        })._thenUnwrap((obj) => obj.data);
    }
    /**
     * Create a simulcast target for the parent live stream. Simulcast target can only
     * be created when the parent live stream is in idle state. Only one simulcast
     * target can be created at a time with this API.
     *
     * @example
     * ```ts
     * const simulcastTarget =
     *   await client.video.liveStreams.createSimulcastTarget(
     *     'LIVE_STREAM_ID',
     *     {
     *       url: 'rtmp://live.example.com/app',
     *       passthrough: 'Example',
     *       stream_key: 'abcdefgh',
     *     },
     *   );
     * ```
     */
    createSimulcastTarget(liveStreamId, body, options) {
        return this._client.post(`/video/v1/live-streams/${liveStreamId}/simulcast-targets`, {
            body,
            defaultBaseURL: 'https://api.mux.com',
            ...options,
        })._thenUnwrap((obj) => obj.data);
    }
    /**
     * Deletes a live stream's static renditions settings for new assets. Further
     * assets made via this live stream will not create static renditions unless
     * re-added.
     *
     * @example
     * ```ts
     * await client.video.liveStreams.deleteNewAssetSettingsStaticRenditions(
     *   'LIVE_STREAM_ID',
     * );
     * ```
     */
    deleteNewAssetSettingsStaticRenditions(liveStreamId, options) {
        return this._client.delete(`/video/v1/live-streams/${liveStreamId}/new-asset-settings/static-renditions`, { defaultBaseURL: 'https://api.mux.com', ...options, headers: { Accept: '*/*', ...options?.headers } });
    }
    /**
     * Deletes the playback ID for the live stream. This will not disable ingest (as
     * the live stream still exists). New attempts to play back the live stream will
     * fail immediately. However, current viewers will be able to continue watching the
     * stream for some period of time.
     *
     * @example
     * ```ts
     * await client.video.liveStreams.deletePlaybackId(
     *   'LIVE_STREAM_ID',
     *   'PLAYBACK_ID',
     * );
     * ```
     */
    deletePlaybackId(liveStreamId, playbackId, options) {
        return this._client.delete(`/video/v1/live-streams/${liveStreamId}/playback-ids/${playbackId}`, {
            defaultBaseURL: 'https://api.mux.com',
            ...options,
            headers: { Accept: '*/*', ...options?.headers },
        });
    }
    /**
     * Delete the simulcast target using the simulcast target ID returned when creating
     * the simulcast target. Simulcast Target can only be deleted when the parent live
     * stream is in idle state.
     *
     * @example
     * ```ts
     * await client.video.liveStreams.deleteSimulcastTarget(
     *   'LIVE_STREAM_ID',
     *   'SIMULCAST_TARGET_ID',
     * );
     * ```
     */
    deleteSimulcastTarget(liveStreamId, simulcastTargetId, options) {
        return this._client.delete(`/video/v1/live-streams/${liveStreamId}/simulcast-targets/${simulcastTargetId}`, { defaultBaseURL: 'https://api.mux.com', ...options, headers: { Accept: '*/*', ...options?.headers } });
    }
    /**
     * Disables a live stream, making it reject incoming RTMP streams until re-enabled.
     * The API also ends the live stream recording immediately when active. Ending the
     * live stream recording adds the `EXT-X-ENDLIST` tag to the HLS manifest which
     * notifies the player that this live stream is over.
     *
     * Mux also closes the encoder connection immediately. Any attempt from the encoder
     * to re-establish connection will fail till the live stream is re-enabled.
     *
     * @example
     * ```ts
     * await client.video.liveStreams.disable('LIVE_STREAM_ID');
     * ```
     */
    disable(liveStreamId, options) {
        return this._client.put(`/video/v1/live-streams/${liveStreamId}/disable`, {
            defaultBaseURL: 'https://api.mux.com',
            ...options,
            headers: { Accept: '*/*', ...options?.headers },
        });
    }
    /**
     * Enables a live stream, allowing it to accept an incoming RTMP stream.
     *
     * @example
     * ```ts
     * await client.video.liveStreams.enable('LIVE_STREAM_ID');
     * ```
     */
    enable(liveStreamId, options) {
        return this._client.put(`/video/v1/live-streams/${liveStreamId}/enable`, {
            defaultBaseURL: 'https://api.mux.com',
            ...options,
            headers: { Accept: '*/*', ...options?.headers },
        });
    }
    /**
     * Reset a live stream key if you want to immediately stop the current stream key
     * from working and create a new stream key that can be used for future broadcasts.
     *
     * @example
     * ```ts
     * const liveStream =
     *   await client.video.liveStreams.resetStreamKey(
     *     'LIVE_STREAM_ID',
     *   );
     * ```
     */
    resetStreamKey(liveStreamId, options) {
        return this._client.post(`/video/v1/live-streams/${liveStreamId}/reset-stream-key`, {
            defaultBaseURL: 'https://api.mux.com',
            ...options,
        })._thenUnwrap((obj) => obj.data);
    }
    /**
     * Fetches information about a live stream's playback ID, through which a viewer
     * can watch the streamed content from this live stream.
     *
     * @example
     * ```ts
     * const playbackId =
     *   await client.video.liveStreams.retrievePlaybackId(
     *     'LIVE_STREAM_ID',
     *     'PLAYBACK_ID',
     *   );
     * ```
     */
    retrievePlaybackId(liveStreamId, playbackId, options) {
        return this._client.get(`/video/v1/live-streams/${liveStreamId}/playback-ids/${playbackId}`, {
            defaultBaseURL: 'https://api.mux.com',
            ...options,
        })._thenUnwrap((obj) => obj.data);
    }
    /**
     * Retrieves the details of the simulcast target created for the parent live
     * stream. Supply the unique live stream ID and simulcast target ID that was
     * returned in the response of create simulcast target request, and Mux will return
     * the corresponding information.
     *
     * @example
     * ```ts
     * const simulcastTarget =
     *   await client.video.liveStreams.retrieveSimulcastTarget(
     *     'LIVE_STREAM_ID',
     *     'SIMULCAST_TARGET_ID',
     *   );
     * ```
     */
    retrieveSimulcastTarget(liveStreamId, simulcastTargetId, options) {
        return this._client.get(`/video/v1/live-streams/${liveStreamId}/simulcast-targets/${simulcastTargetId}`, {
            defaultBaseURL: 'https://api.mux.com',
            ...options,
        })._thenUnwrap((obj) => obj.data);
    }
    /**
     * Configures a live stream to receive embedded closed captions. The resulting
     * Asset's subtitle text track will have `closed_captions: true` set.
     *
     * @example
     * ```ts
     * const liveStream =
     *   await client.video.liveStreams.updateEmbeddedSubtitles(
     *     'LIVE_STREAM_ID',
     *     { embedded_subtitles: [{ passthrough: 'Example' }] },
     *   );
     * ```
     */
    updateEmbeddedSubtitles(liveStreamId, body, options) {
        return this._client.put(`/video/v1/live-streams/${liveStreamId}/embedded-subtitles`, {
            body,
            defaultBaseURL: 'https://api.mux.com',
            ...options,
        })._thenUnwrap((obj) => obj.data);
    }
    /**
     * Updates a live stream's automatic-speech-recognition-generated subtitle
     * configuration. Automatic speech recognition subtitles can be removed by sending
     * an empty array in the request payload.
     *
     * @example
     * ```ts
     * const liveStream =
     *   await client.video.liveStreams.updateGeneratedSubtitles(
     *     'LIVE_STREAM_ID',
     *     {
     *       generated_subtitles: [
     *         {
     *           name: 'English CC (ASR)',
     *           language_code: 'en',
     *           passthrough: 'Example',
     *         },
     *       ],
     *     },
     *   );
     * ```
     */
    updateGeneratedSubtitles(liveStreamId, body, options) {
        return this._client.put(`/video/v1/live-streams/${liveStreamId}/generated-subtitles`, {
            body,
            defaultBaseURL: 'https://api.mux.com',
            ...options,
        })._thenUnwrap((obj) => obj.data);
    }
    /**
     * Updates a live stream's static renditions settings for new assets. Further
     * assets made via this live stream will create static renditions per the settings
     * provided. You must provide all static renditions desired.
     *
     * @example
     * ```ts
     * const liveStream =
     *   await client.video.liveStreams.updateNewAssetSettingsStaticRenditions(
     *     'LIVE_STREAM_ID',
     *     {
     *       static_renditions: [
     *         { resolution: 'audio-only' },
     *         { resolution: 'highest' },
     *       ],
     *     },
     *   );
     * ```
     */
    updateNewAssetSettingsStaticRenditions(liveStreamId, body, options) {
        return this._client.put(`/video/v1/live-streams/${liveStreamId}/new-asset-settings/static-renditions`, {
            body,
            defaultBaseURL: 'https://api.mux.com',
            ...options,
        })._thenUnwrap((obj) => obj.data);
    }
}
export class LiveStreamsBasePage extends BasePage {
}
LiveStreams.LiveStreamsBasePage = LiveStreamsBasePage;
//# sourceMappingURL=live-streams.mjs.map